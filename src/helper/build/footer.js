// Footer generation helpers for build
import { existsSync } from "fs";
import { readFile } from "fs/promises";
import { dirname, join, resolve } from "path";
import { URL } from "url";
import { renderFile } from "../fileRenderer.js";

/**
 * Generate footer HTML from footer.md and package.json
 * @param {string} source - resolved source path with trailing slash
 * @param {string} _source - original source path
 * @param {number} buildId - the current build ID
 * @returns {Promise<string>} Footer HTML
 */
export async function getFooter(source, _source, buildId) {
  const footerParts = [];
  
  // Try to read footer.md from source root
  const footerPath = join(source, 'footer.md');
  try {
    if (existsSync(footerPath)) {
      const footerMd = await readFile(footerPath, 'utf8');
      const footerHtml = renderFile({ fileContents: footerMd, type: '.md' });
      footerParts.push(`<div class="footer-content">${footerHtml}</div>`);
    }
  } catch (e) {
    console.error(`Error reading footer.md: ${e.message}`);
  }
  
  // Try to read package.json from doc repo (check both source dir and parent)
  let docPackage = null;
  const sourceDir = resolve(_source);
  const packagePaths = [
    join(sourceDir, 'package.json'),           // In source dir itself
    join(sourceDir, '..', 'package.json'),     // One level up (if docs is a subfolder)
  ];
  
  for (const packagePath of packagePaths) {
    try {
      if (existsSync(packagePath)) {
        const packageJson = await readFile(packagePath, 'utf8');
        docPackage = JSON.parse(packageJson);
        console.log(`Found doc package.json at ${packagePath}`);
        break;
      }
    } catch (e) {
      // Continue to next path
    }
  }
  
  // Get ursa version from ursa's own package.json
  // Use import.meta.url to find the package.json relative to this file
  let ursaVersion = 'unknown';
  try {
    // From src/helper/build/footer.js, go up to package root
    const currentFileUrl = new URL(import.meta.url);
    const currentDir = dirname(currentFileUrl.pathname);
    const ursaPackagePath = resolve(currentDir, '..', '..', '..', 'package.json');
    
    if (existsSync(ursaPackagePath)) {
      const ursaPackageJson = await readFile(ursaPackagePath, 'utf8');
      const ursaPackage = JSON.parse(ursaPackageJson);
      ursaVersion = ursaPackage.version;
      console.log(`Found ursa package.json at ${ursaPackagePath}, version: ${ursaVersion}`);
    }
  } catch (e) {
    console.error(`Error reading ursa package.json: ${e.message}`);
  }
  
  // Build meta line: version, build id, timestamp, "generated by ursa"
  const metaParts = [];
  if (docPackage?.version) {
    metaParts.push(`v${docPackage.version}`);
  }
  metaParts.push(`build ${buildId}`);
  
  // Full date/time in a readable format
  const now = new Date();
  const timestamp = now.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, ' UTC');
  metaParts.push(timestamp);
  
  metaParts.push(`Generated by <a href="https://www.npmjs.com/package/@kenjura/ursa">ursa</a> v${ursaVersion}`);
  
  footerParts.push(`<div class="footer-meta">${metaParts.join(' • ')}</div>`);
  
  // Copyright line from doc package.json
  if (docPackage?.copyright) {
    footerParts.push(`<div class="footer-copyright">${docPackage.copyright}</div>`);
  } else if (docPackage?.author) {
    const year = new Date().getFullYear();
    const author = typeof docPackage.author === 'string' ? docPackage.author : docPackage.author.name;
    if (author) {
      footerParts.push(`<div class="footer-copyright">© ${year} ${author}</div>`);
    }
  }
  
  // Try to get git short hash of doc repo (as HTML comment)
  try {
    const { execSync } = await import('child_process');
    const gitHash = execSync('git rev-parse --short HEAD', {
      cwd: resolve(_source),
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
    if (gitHash) {
      footerParts.push(`<!-- git: ${gitHash} -->`);
    }
  } catch (e) {
    // Not a git repo or git not available - silently skip
  }
  
  return footerParts.join('\n');
}
